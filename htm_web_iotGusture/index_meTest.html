<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gesture Control Hub</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>
  <link rel="stylesheet" href="./style.css" type="text/css">
</head>
<body>
  <div class="app-container">
    <!-- Landing Page -->
    <div id="landing" class="landing-page">
      <div class="landing-content">
        <div class="hero-icon">üëã</div>
        <h1 class="hero-title">Gesture Control Hub</h1>
        <p class="hero-subtitle">Control IoT devices with simple hand gestures</p>
        
        <div class="features">
          <div class="feature-card">
            <div class="feature-icon">üìπ</div>
            <p>Uses your webcam to detect hand gestures in real-time</p>
          </div>
          
          <div class="feature-card">
            <div class="feature-icon">‚úåÔ∏è</div>
            <p>Control your car with intuitive hand movements</p>
          </div>
          
          <div class="feature-card">
            <div class="feature-icon">üöó</div>
            <p>Real-time gesture recognition for smooth control</p>
          </div>
        </div>
        
        <button id="getStarted" class="get-started-btn">
          <span>Get Started</span>
          <div class="btn-icon">‚úì</div>
        </button>
      </div>
    </div>

    <!-- Main App -->
    <div id="mainApp" class="main-app hidden">
      <div class="app-header">
        <button id="backBtn" class="back-btn">‚Üê</button>
        <h1>ü§ñ Gesture Control</h1>
        <div class="status-indicator">
          <div class="status-dot"></div>
          <span id="connectionStatus">Live</span>
        </div>
      </div>

      <div class="camera-section">
        <div class="camera-container">
          <video id="video" autoplay playsinline></video>
          <canvas id="canvas"></canvas>
          
          <div id="gesture" class="gesture-display">
            <div class="gesture-icon">ü§ö</div>
            <div class="gesture-text">Initializing...</div>
          </div>

          <div class="confidence-meter">
            <div class="confidence-label">Detection Confidence</div>
            <div class="confidence-bar">
              <div class="confidence-fill" id="confidenceFill"></div>
            </div>
            <div class="confidence-value" id="confidenceValue">0%</div>
          </div>
        </div>

        <div class="controls-info">
          <h3>Gesture Commands</h3>
          <div class="gesture-list">
            <div class="gesture-item">
              <span class="gesture-emoji">‚úä</span>
              <span class="gesture-name">Fist</span>
              <span class="gesture-action">Forward</span>
            </div>
            <div class="gesture-item">
              <span class="gesture-emoji">üëç</span>
              <span class="gesture-name">Thumb Up</span>
              <span class="gesture-action">Left</span>
            </div>
            <div class="gesture-item">
              <span class="gesture-emoji">ü§ô</span>
              <span class="gesture-name">Shaka</span>
              <span class="gesture-action">Right</span>
            </div>
            <div class="gesture-item">
              <span class="gesture-emoji">‚úã</span>
              <span class="gesture-name">Open Hand</span>
              <span class="gesture-action">Stop</span>
            </div>
            <div class="gesture-item">
              <span class="gesture-emoji">‚úåÔ∏è</span>
              <span class="gesture-name">Peace</span>
              <span class="gesture-action">Reverse</span>
            </div>
          </div>
        </div>
      </div>

      <!-- Command Status Display -->
      <div class="command-status">
        <h3>Command Status</h3>
        <div id="lastCommand" class="last-command">None</div>
        <div id="commandTime" class="command-time">--:--:--</div>
      </div>

      <!-- Debug Panel -->
      <div class="debug-panel">
        <h4>Debug Info</h4>
        <div id="debugInfo">
          <div>Fingers: <span id="fingerCount">0</span></div>
          <div>Gesture Buffer: <span id="gestureBuffer">Empty</span></div>
          <div>Stability: <span id="stabilityCount">0</span></div>
        </div>
      </div>
    </div>

    <!-- Error Modal -->
    <div id="errorModal" class="modal hidden">
      <div class="modal-content">
        <div class="modal-header">
          <div class="error-icon">‚ö†Ô∏è</div>
          <h3 id="errorTitle">Camera Access Required</h3>
        </div>
        <div class="modal-body">
          <p id="errorMessage">Please allow camera access to use gesture detection.</p>
          <div id="errorInstructions" class="instructions">
            <ol>
              <li>Click the camera icon in your browser's address bar</li>
              <li>Select "Allow" for camera access</li>
              <li>Refresh the page</li>
            </ol>
          </div>
        </div>
        <div class="modal-footer">
          <button id="retryBtn" class="retry-btn">Try Again</button>
          <button id="closeModal" class="close-btn">Close</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Global variables
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const gestureDisplay = document.getElementById('gesture');
    const confidenceFill = document.getElementById('confidenceFill');
    const confidenceValue = document.getElementById('confidenceValue');
    const connectionStatus = document.getElementById('connectionStatus');
    const lastCommand = document.getElementById('lastCommand');
    const commandTime = document.getElementById('commandTime');
    
    // Enhanced gesture detection variables
    let currentGesture = '';
    let gestureConfidence = 0;
    let lastSentCommand = null;
    let hands = null;
    let gestureBuffer = [];
    let stableGestureCount = 0;
    const STABILITY_THRESHOLD = 8; // Increased for better stability
    const BUFFER_SIZE = 10;
    const MIN_CONFIDENCE = 0.8;
    
    // Timing variables
    let lastCommandTime = 0;
    let commandCooldown = 500; // 500ms cooldown between commands
    let autoStopDisabled = false; // Flag to disable auto-stop

    // Blynk configuration
    const blynkToken = "tVIYzfAnG877yK7LVE8CDzRAXsOOYymU";
    const virtualPin = "V0";

    // CORS Proxy URLs
    const corsProxies = [
      'https://cors-anywhere.herokuapp.com/',
      'https://api.allorigins.win/raw?url=',
      'https://corsproxy.io/?'
    ];

    // Page navigation
    document.getElementById('getStarted').addEventListener('click', () => {
      document.getElementById('landing').classList.add('hidden');
      document.getElementById('mainApp').classList.remove('hidden');
      initializeApp();
    });

    document.getElementById('backBtn').addEventListener('click', () => {
      document.getElementById('mainApp').classList.add('hidden');
      document.getElementById('landing').classList.remove('hidden');
      cleanup();
    });

    // Modal controls
    document.getElementById('retryBtn').addEventListener('click', () => {
      document.getElementById('errorModal').classList.add('hidden');
      initializeCamera();
    });

    document.getElementById('closeModal').addEventListener('click', () => {
      document.getElementById('errorModal').classList.add('hidden');
    });

    // Initialize app
    function initializeApp() {
      setCanvasSize();
      initializeCamera();
      window.addEventListener('resize', setCanvasSize);
    }

    // Set canvas dimensions
    function setCanvasSize() {
      const container = document.querySelector('.camera-container');
      const isMobile = window.innerWidth <= 768;
      
      if (isMobile) {
        canvas.width = Math.min(window.innerWidth - 40, 600);
        canvas.height = Math.min((window.innerWidth - 40) * 0.75, 450);
      } else {
        canvas.width = 640;
        canvas.height = 480;
      }
    }

    // Check secure context
    function isSecureContext() {
      return location.protocol === 'https:' || 
             location.hostname === 'localhost' || 
             location.hostname === '127.0.0.1';
    }

    // Show error modal
    function showError(title, message, showInstructions = false) {
      document.getElementById('errorTitle').textContent = title;
      document.getElementById('errorMessage').textContent = message;
      document.getElementById('errorInstructions').style.display = showInstructions ? 'block' : 'none';
      document.getElementById('errorModal').classList.remove('hidden');
    }

    // Initialize camera
    async function initializeCamera() {
      try {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          showError("Camera Not Supported", "Your browser doesn't support camera access.");
          return;
        }

        if (!isSecureContext()) {
          showError("Secure Connection Required", "Camera access requires HTTPS connection.");
          return;
        }

        updateGestureDisplay("Requesting Camera...", "üé•", 0);
        
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: { ideal: 640, min: 320 },
            height: { ideal: 480, min: 240 },
            facingMode: 'user'
          },
          audio: false
        });
        
        video.srcObject = stream;
        
        return new Promise((resolve, reject) => {
          video.onloadedmetadata = () => {
            video.play().then(() => {
              updateGestureDisplay("Camera Ready", "‚úÖ", 1);
              initializeHandDetection();
              resolve();
            }).catch(reject);
          };
          
          video.onerror = reject;
          setTimeout(() => reject(new Error('Video load timeout')), 10000);
        });
        
      } catch (error) {
        console.error('Camera initialization failed:', error);
        connectionStatus.textContent = 'Camera Error';
        
        if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
          showError("Permission Denied", "Camera access was denied. Please allow camera permissions.", true);
        } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
          showError("No Camera Found", "No camera device was detected on your system.");
        } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
          showError("Camera Busy", "Camera is being used by another application.");
        } else {
          showError("Camera Error", "An error occurred while accessing the camera.");
        }
        
        updateGestureDisplay("Camera Error", "‚ùå", 0);
      }
    }

    // Initialize hand detection
    function initializeHandDetection() {
      hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
      });

      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.8,
        minTrackingConfidence: 0.8,
      });

      hands.onResults(onResults);

      async function processFrame() {
        if (video.readyState >= 2 && video.videoWidth > 0) {
          try {
            await hands.send({image: video});
          } catch (error) {
            console.error('Hand detection error:', error);
          }
        }
        requestAnimationFrame(processFrame);
      }
      
      updateGestureDisplay("AI Loading...", "ü§ñ", 0.5);
      processFrame();
      
      setTimeout(() => {
        updateGestureDisplay("Ready to Detect", "üëã", 1);
        connectionStatus.textContent = 'Ready';
      }, 2000);
    }

    // Update gesture display
    function updateGestureDisplay(text, icon, confidence) {
      const gestureIcon = document.querySelector('.gesture-icon');
      const gestureText = document.querySelector('.gesture-text');
      
      gestureIcon.textContent = icon;
      gestureText.textContent = text;
      
      // Update confidence
      confidenceFill.style.width = (confidence * 100) + '%';
      confidenceValue.textContent = Math.round(confidence * 100) + '%';
      
      // Add active class for recognized gestures
      if (confidence > 0.7) {
        gestureDisplay.classList.add('active');
      } else {
        gestureDisplay.classList.remove('active');
      }
    }

    // Enhanced gesture detection with improved accuracy
    function detectGesture(landmarks, handedness) {
      // Calculate distances for better accuracy
      const calculateDistance = (point1, point2) => {
        return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));
      };

      // Get key landmarks
      const thumb_tip = landmarks[4];
      const thumb_ip = landmarks[3];
      const thumb_mcp = landmarks[2];
      const index_tip = landmarks[8];
      const index_pip = landmarks[6];
      const index_mcp = landmarks[5];
      const middle_tip = landmarks[12];
      const middle_pip = landmarks[10];
      const middle_mcp = landmarks[9];
      const ring_tip = landmarks[16];
      const ring_pip = landmarks[14];
      const ring_mcp = landmarks[13];
      const pinky_tip = landmarks[20];
      const pinky_pip = landmarks[18];
      const pinky_mcp = landmarks[17];
      const wrist = landmarks[0];

      // Enhanced finger extension detection
      const isFingerExtended = (tip, pip, mcp) => {
        const tip_pip_dist = calculateDistance(tip, pip);
        const pip_mcp_dist = calculateDistance(pip, mcp);
        const tip_mcp_dist = calculateDistance(tip, mcp);
        
        // Check if finger is straight and extended
        const ratio = tip_mcp_dist / (tip_pip_dist + pip_mcp_dist);
        const angle_threshold = tip.y < pip.y && pip.y < mcp.y;
        
        return ratio > 0.8 && angle_threshold;
      };

      // Enhanced thumb detection
      const isThumbExtended = () => {
        const thumb_extended = handedness === "Right" 
          ? thumb_tip.x > thumb_ip.x && thumb_ip.x > thumb_mcp.x
          : thumb_tip.x < thumb_ip.x && thumb_ip.x < thumb_mcp.x;
        
        // Additional check for thumb angle
        const thumb_angle = calculateDistance(thumb_tip, thumb_mcp);
        const thumb_palm_dist = calculateDistance(thumb_tip, landmarks[17]); // Distance to pinky MCP
        
        return thumb_extended && thumb_angle > 0.08 && thumb_palm_dist > 0.12;
      };

      // Check each finger
      const fingers = {
        thumb: isThumbExtended(),
        index: isFingerExtended(index_tip, index_pip, index_mcp),
        middle: isFingerExtended(middle_tip, middle_pip, middle_mcp),
        ring: isFingerExtended(ring_tip, ring_pip, ring_mcp),
        pinky: isFingerExtended(pinky_tip, pinky_pip, pinky_mcp)
      };

      const extendedFingers = Object.values(fingers).filter(Boolean).length;
      
      // Update debug info
      updateDebugInfo(extendedFingers, fingers);

      // Enhanced gesture classification with stricter criteria
      if (extendedFingers === 0) {
        // All fingers closed - check if it's a proper fist
        const fist_compactness = calculateFistCompactness(landmarks);
        if (fist_compactness > 0.6) {
          return "Forward";
        }
        return "Unknown";
      }
      
      if (fingers.thumb && extendedFingers === 1) {
        // Only thumb extended - check thumb angle
        const thumb_angle = Math.abs(thumb_tip.y - thumb_mcp.y);
        if (thumb_angle < 0.15) { // Thumb pointing up/down
          return "Left";
        }
        return "Unknown";
      }
      
      if (fingers.thumb && fingers.pinky && extendedFingers === 2) {
        // Shaka gesture - check if other fingers are properly closed
        const middle_fingers_closed = !fingers.index && !fingers.middle && !fingers.ring;
        if (middle_fingers_closed) {
          return "Right";
        }
        return "Unknown";
      }
      
      if (extendedFingers === 5) {
        // All fingers extended - check if hand is flat
        const hand_flatness = calculateHandFlatness(landmarks);
        if (hand_flatness > 0.7) {
          return "Stop";
        }
        return "Unknown";
      }
      
      if (fingers.index && fingers.middle && extendedFingers === 2) {
        // Peace sign - check if fingers are properly separated
        const finger_separation = calculateDistance(index_tip, middle_tip);
        const other_fingers_closed = !fingers.thumb && !fingers.ring && !fingers.pinky;
        if (finger_separation > 0.05 && other_fingers_closed) {
          return "Backward";
        }
        return "Unknown";
      }

      return "Unknown";
    }

    // Calculate fist compactness
    function calculateFistCompactness(landmarks) {
      const fingertips = [4, 8, 12, 16, 20]; // Thumb, index, middle, ring, pinky tips
      const palm_center = landmarks[0]; // Wrist as reference
      
      let total_distance = 0;
      fingertips.forEach(tip_index => {
        total_distance += Math.sqrt(
          Math.pow(landmarks[tip_index].x - palm_center.x, 2) +
          Math.pow(landmarks[tip_index].y - palm_center.y, 2)
        );
      });
      
      const avg_distance = total_distance / fingertips.length;
      return Math.max(0, 1 - (avg_distance / 0.3)); // Normalize to 0-1
    }

    // Calculate hand flatness
    function calculateHandFlatness(landmarks) {
      const fingertips = [4, 8, 12, 16, 20];
      const mcp_joints = [2, 5, 9, 13, 17];
      
      let tip_y_sum = 0;
      let mcp_y_sum = 0;
      
      fingertips.forEach(tip => tip_y_sum += landmarks[tip].y);
      mcp_joints.forEach(mcp => mcp_y_sum += landmarks[mcp].y);
      
      const avg_tip_y = tip_y_sum / fingertips.length;
      const avg_mcp_y = mcp_y_sum / mcp_joints.length;
      
      const flatness = Math.max(0, 1 - Math.abs(avg_tip_y - avg_mcp_y) / 0.2);
      return flatness;
    }

    // Update debug information
    function updateDebugInfo(fingerCount, fingers) {
      document.getElementById('fingerCount').textContent = fingerCount;
      document.getElementById('gestureBuffer').textContent = gestureBuffer.slice(-3).join(', ') || 'Empty';
      document.getElementById('stabilityCount').textContent = stableGestureCount;
    }

    // Process hand detection results
    function onResults(results) {
      if (!canvas || !ctx) return;
      
      ctx.save();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw video frame
      if (results.image) {
        ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
      }

      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        const handedness = results.multiHandedness[0].label;
        gestureConfidence = results.multiHandedness[0].score;

        // Draw hand landmarks with better visibility
        if (typeof drawConnectors === 'function' && typeof HAND_CONNECTIONS !== 'undefined') {
          ctx.strokeStyle = '#00FF00';
          ctx.lineWidth = 3;
          ctx.shadowColor = '#00FF00';
          ctx.shadowBlur = 5;
          drawConnectors(ctx, landmarks, HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 3 });
        }
        
        if (typeof drawLandmarks === 'function') {
          ctx.fillStyle = '#FF0000';
          ctx.strokeStyle = '#FFFFFF';
          ctx.lineWidth = 2;
          ctx.shadowColor = '#FF0000';
          ctx.shadowBlur = 3;
          drawLandmarks(ctx, landmarks, { color: '#FF0000', lineWidth: 2, radius: 4 });
        }

        // Enhanced gesture detection
        if (gestureConfidence > MIN_CONFIDENCE) {
          const gesture = detectGesture(landmarks, handedness);
          
          // Add to gesture buffer
          gestureBuffer.push(gesture);
          if (gestureBuffer.length > BUFFER_SIZE) {
            gestureBuffer.shift();
          }
          
          // Check gesture stability using buffer
          const recentGestures = gestureBuffer.slice(-5);
          const dominantGesture = getMostFrequentGesture(recentGestures);
          
          if (dominantGesture === currentGesture && dominantGesture !== "Unknown") {
            stableGestureCount++;
          } else {
            stableGestureCount = 0;
            currentGesture = dominantGesture;
          }

          const gestureIcons = {
            'Forward': '‚¨ÜÔ∏è',
            'Left': '‚¨ÖÔ∏è',
            'Right': '‚û°Ô∏è',
            'Stop': 'üõë',
            'Backward': '‚¨áÔ∏è',
            'Unknown': '‚ùì'
          };

          updateGestureDisplay(dominantGesture, gestureIcons[dominantGesture] || 'ü§ñ', gestureConfidence);
          
          // Send command only if gesture is stable and different from last sent
          if (stableGestureCount >= STABILITY_THRESHOLD && 
              dominantGesture !== "Unknown" && 
              dominantGesture !== lastSentCommand &&
              Date.now() - lastCommandTime > commandCooldown) {
            sendToBlynk(dominantGesture);
          }
        }
      } else {
        // No hand detected
        gestureBuffer.push("NoHand");
        if (gestureBuffer.length > BUFFER_SIZE) {
          gestureBuffer.shift();
        }
        
        updateGestureDisplay("No Hand Detected", "üëª", 0);
        currentGesture = '';
        stableGestureCount = 0;
        
        // Only send stop if we previously sent a movement command
        if (lastSentCommand && lastSentCommand !== "Stop" && 
            Date.now() - lastCommandTime > 2000) { // Wait 2 seconds before auto-stop
          sendToBlynk("Stop");
        }
      }

      ctx.restore();
    }

    // Get most frequent gesture from buffer
    function getMostFrequentGesture(gestures) {
      const counts = {};
      gestures.forEach(gesture => {
        counts[gesture] = (counts[gesture] || 0) + 1;
      });
      
      let maxCount = 0;
      let dominantGesture = "Unknown";
      
      for (const [gesture, count] of Object.entries(counts)) {
        if (count > maxCount && gesture !== "Unknown" && gesture !== "NoHand") {
          maxCount = count;
          dominantGesture = gesture;
        }
      }
      
      return dominantGesture;
    }

    // Send command to Blynk
    function sendToBlynk(gesture) {
      if (gesture === lastSentCommand) return;

      const gestureMap = {
        "Forward": "F",
        "Left": "L", 
        "Right": "R",
        "Stop": "S",
        "Backward": "B"
      };

      const command = gestureMap[gesture];
      
      if (command) {
        lastSentCommand = gesture;
        lastCommandTime = Date.now();
        
        // Update UI immediately
        updateCommandStatus(gesture, command);
        
        // Send command
        sendBlynkCommand(command);
        
        console.log(`üéØ Sending command: ${gesture} (${command})`);
      }
    }

    // Send Blynk command with multiple fallback methods
    async function sendBlynkCommand(command) {
      const blynkUrl = `https://blynk.cloud/external/api/update?token=${blynkToken}&${virtualPin}=${command}`;
      
      // Method 1: Direct fetch
      try {
        const response = await fetch(blynkUrl, {
          method: 'GET',
          mode: 'no-cors'
        });
        console.log(`‚úÖ Command sent: ${command}`);
        connectionStatus.textContent = 'Connected';
        return;
      } catch (error) {
        console.log('Direct method failed, trying alternatives...');
      }

      // Method 2: Image pixel method (most reliable for no-cors)
      try {
        const img = new Image();
        img.onload = img.onerror = () => {
          console.log(`‚úÖ Command sent via image method: ${command}`);
          connectionStatus.textContent = 'Connected';
        };
        img.src = blynkUrl + '&_=' + Date.now();
      } catch (error) {
        console.error('All methods failed:', error);
        connectionStatus.textContent = 'Connection Error';
      }
    }

    // Update command status display
    function updateCommandStatus(gesture, command) {
      lastCommand.textContent = `${gesture} (${command})`;
      commandTime.textContent = new Date().toLocaleTimeString();
    }

    // Cleanup function
    function cleanup() {
      if (video.srcObject) {
        video.srcObject.getTracks().forEach(track => track.stop());
        video.srcObject = null;
      }
      if (hands) {
        hands.close();
        hands = null;
      }
      lastSentCommand = null;
      currentGesture = '';
      stableGestureCount = 0;
      gestureBuffer = [];
    }

    // Handle page visibility changes
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        if (video.srcObject) {
          video.srcObject.getTracks().forEach(track => track.enabled = false);
        }
      } else {
        if (video.srcObject) {
          video.srcObject.getTracks().forEach(track => track.enabled = true);
        }
      }
    });

    // Handle window unload
    window.addEventListener('beforeunload', cleanup);

    // REMOVED: Auto-stop safety feature that was causing issues
    // No more automatic stop commands every 3 seconds
    
    // Removed: Connection health check that was interfering
    // The periodic connection test was causing unwanted stop commands
  </script>
</body>
</html>